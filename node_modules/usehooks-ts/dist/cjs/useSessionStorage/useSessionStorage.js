"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useSessionStorage = void 0;
var react_1 = require("react");
var useEventCallback_1 = require("../useEventCallback");
var useEventListener_1 = require("../useEventListener");
// type SetValue<T> = Dispatch<SetStateAction<T>>
var IS_SERVER = typeof window === 'undefined';
/**
 * Custom hook for using session storage to persist state across page reloads.
 * @template T - The type of the state to be stored in session storage.
 * @param {string} key - The key under which the value will be stored in session storage.
 * @param {T | (() => T)} initialValue - The initial value of the state or a function that returns the initial value.
 * @param {?UseSessionStorageOptions<T>} [options] - Options for customizing the behavior of serialization and deserialization (optional).
 * @param {?boolean} [options.initializeWithValue] - If `true` (default), the hook will initialize reading the session storage. In SSR, you should set it to `false`, returning `undefined` initially.
 * @param {(value: T) => string} [options.serializer] - A function to serialize the value before storing it.
 * @returns {[T, Dispatch<SetStateAction<T>>]} A tuple containing the stored value and a function to set the value.
 * @see [Documentation](https://usehooks-ts.com/react-hook/use-session-storage)
 * @see [MDN Session Storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage)
 * @example
 * const [count, setCount] = useSessionStorage('count', 0);
 * // Access the `count` value and the `setCount` function to update it.
 */
function useSessionStorage(key, initialValue, options) {
    if (options === void 0) { options = {}; }
    var _a = options.initializeWithValue, initializeWithValue = _a === void 0 ? true : _a;
    if (IS_SERVER) {
        initializeWithValue = false;
    }
    var serializer = (0, react_1.useCallback)(function (value) {
        if (options.serializer) {
            return options.serializer(value);
        }
        return JSON.stringify(value);
    }, [options]);
    var deserializer = (0, react_1.useCallback)(function (value) {
        if (options.deserializer) {
            return options.deserializer(value);
        }
        // Support 'undefined' as a value
        if (value === 'undefined') {
            return undefined;
        }
        var defaultValue = initialValue instanceof Function ? initialValue() : initialValue;
        var parsed;
        try {
            parsed = JSON.parse(value);
        }
        catch (error) {
            console.error('Error parsing JSON:', error);
            return defaultValue; // Return initialValue if parsing fails
        }
        return parsed;
    }, [options, initialValue]);
    // Get from session storage then
    // parse stored json or return initialValue
    var readValue = (0, react_1.useCallback)(function () {
        var initialValueToUse = initialValue instanceof Function ? initialValue() : initialValue;
        // Prevent build error "window is undefined" but keep keep working
        if (IS_SERVER) {
            return initialValueToUse;
        }
        try {
            var raw = window.sessionStorage.getItem(key);
            return raw ? deserializer(raw) : initialValueToUse;
        }
        catch (error) {
            console.warn("Error reading sessionStorage key \u201C".concat(key, "\u201D:"), error);
            return initialValueToUse;
        }
    }, [initialValue, key, deserializer]);
    var _b = (0, react_1.useState)(function () {
        if (initializeWithValue) {
            return readValue();
        }
        return undefined;
    }), storedValue = _b[0], setStoredValue = _b[1];
    // Return a wrapped version of useState's setter function that ...
    // ... persists the new value to sessionStorage.
    var setValue = (0, useEventCallback_1.useEventCallback)(function (value) {
        // Prevent build error "window is undefined" but keeps working
        if (IS_SERVER) {
            console.warn("Tried setting sessionStorage key \u201C".concat(key, "\u201D even though environment is not a client"));
        }
        try {
            // Allow value to be a function so we have the same API as useState
            var newValue = value instanceof Function ? value(readValue()) : value;
            // Save to session storage
            window.sessionStorage.setItem(key, serializer(newValue));
            // Save state
            setStoredValue(newValue);
            // We dispatch a custom event so every similar useSessionStorage hook is notified
            window.dispatchEvent(new StorageEvent('session-storage', { key: key }));
        }
        catch (error) {
            console.warn("Error setting sessionStorage key \u201C".concat(key, "\u201D:"), error);
        }
    });
    (0, react_1.useEffect)(function () {
        setStoredValue(readValue());
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [key]);
    var handleStorageChange = (0, react_1.useCallback)(function (event) {
        if ((event === null || event === void 0 ? void 0 : event.key) && event.key !== key) {
            return;
        }
        setStoredValue(readValue());
    }, [key, readValue]);
    // this only works for other documents, not the current one
    (0, useEventListener_1.useEventListener)('storage', handleStorageChange);
    // this is a custom event, triggered in writeValueToSessionStorage
    // See: useSessionStorage()
    (0, useEventListener_1.useEventListener)('session-storage', handleStorageChange);
    return [storedValue, setValue];
}
exports.useSessionStorage = useSessionStorage;
