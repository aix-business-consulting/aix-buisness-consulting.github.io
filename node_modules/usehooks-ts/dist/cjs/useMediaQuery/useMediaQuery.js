"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useMediaQuery = void 0;
var react_1 = require("react");
var useIsomorphicLayoutEffect_1 = require("../useIsomorphicLayoutEffect");
var IS_SERVER = typeof window === 'undefined';
/**
 * Custom hook for tracking the state of a media query.
 * @param {string} query - The media query to track.
 * @param {boolean | ?UseMediaQueryOptions} [options] - The default value to return if the hook is being run on the server (default is `false`).
 * @param {?boolean} [options.defaultValue] - The default value to return if the hook is being run on the server (default is `false`).
 * @param {?boolean} [options.initializeWithValue] - If `true` (default), the hook will initialize reading the media query. In SSR, you should set it to `false`, returning `undefined`  or `options.defaultValue` initially.
 * @returns {boolean | undefined} The current state of the media query (true if the query matches, false otherwise).
 * @see [Documentation](https://usehooks-ts.com/react-hook/use-media-query)
 * @see [MDN Match Media](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia)
 * @example
 * const isSmallScreen = useMediaQuery('(max-width: 600px)');
 * // Use `isSmallScreen` to conditionally apply styles or logic based on the screen size.
 */
function useMediaQuery(query, options) {
    var _a, _b;
    // TODO: Refactor this code after the deprecated signature has been removed.
    var defaultValue = typeof options === 'boolean' ? options : (_a = options === null || options === void 0 ? void 0 : options.defaultValue) !== null && _a !== void 0 ? _a : false;
    var initializeWithValue = typeof options === 'boolean'
        ? undefined
        : (_b = options === null || options === void 0 ? void 0 : options.initializeWithValue) !== null && _b !== void 0 ? _b : undefined;
    if (IS_SERVER) {
        initializeWithValue = false;
    }
    var _c = (0, react_1.useState)(function () {
        if (initializeWithValue) {
            return getMatches(query);
        }
        return defaultValue;
    }), matches = _c[0], setMatches = _c[1];
    var getMatches = function (query) {
        if (typeof window !== 'undefined') {
            return window.matchMedia(query).matches;
        }
        return defaultValue;
    };
    /** Handles the change event of the media query. */
    function handleChange() {
        setMatches(getMatches(query));
    }
    (0, useIsomorphicLayoutEffect_1.useIsomorphicLayoutEffect)(function () {
        var matchMedia = window.matchMedia(query);
        // Triggered at the first client-side load and if query changes
        handleChange();
        // Use deprecated `addListener` and `removeListener` to support Safari < 14 (#135)
        if (matchMedia.addListener) {
            matchMedia.addListener(handleChange);
        }
        else {
            matchMedia.addEventListener('change', handleChange);
        }
        return function () {
            if (matchMedia.removeListener) {
                matchMedia.removeListener(handleChange);
            }
            else {
                matchMedia.removeEventListener('change', handleChange);
            }
        };
    }, [query]);
    return matches;
}
exports.useMediaQuery = useMediaQuery;
