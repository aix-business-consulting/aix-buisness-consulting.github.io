"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useDebounceValue = void 0;
var react_1 = require("react");
var useDebounceCallback_1 = require("../useDebounceCallback");
/**
 * Returns a debounced version of the provided value, along with a function to update it.
 * @template T - The type of the value.
 * @param {T | (() => T)} initialValue - The value to be debounced.
 * @param {number} delay - The delay in milliseconds before the value is updated (default is 500ms).
 * @param {object} [options] - Optional configurations for the debouncing behavior.
 * @param {?boolean} [options.leading] - Determines if the debounced function should be invoked on the leading edge of the timeout (default to false).
 * @param {?boolean} [options.trailing] - Determines if the debounced function should be invoked on the trailing edge of the timeout (default to false).
 * @param {?(left: T, right: T) => boolean} [options.equalityFn] - A function to determine if the value has changed. Defaults to a function that checks if the value is strictly equal to the previous value.
 * @param {?number} [options.maxWait] - The maximum time the debounced function is allowed to be delayed before it's invoked.
 * @returns {[T, DebouncedState<(value: T) => void>]} An array containing the debounced value and the function to update it.
 * @see [Documentation](https://usehooks-ts.com/react-hook/use-debounce-value)
 * @example
 * const [debouncedValue, updateDebouncedValue] = useDebounceValue(inputValue, 500, { leading: true });
 */
function useDebounceValue(initialValue, delay, options) {
    var _a;
    var eq = (_a = options === null || options === void 0 ? void 0 : options.equalityFn) !== null && _a !== void 0 ? _a : (function (left, right) { return left === right; });
    var unwrappedInitialValue = initialValue instanceof Function ? initialValue() : initialValue;
    var _b = (0, react_1.useState)(unwrappedInitialValue), debouncedValue = _b[0], setDebouncedValue = _b[1];
    var previousValueRef = (0, react_1.useRef)(unwrappedInitialValue);
    var updateDebouncedValue = (0, useDebounceCallback_1.useDebounceCallback)(setDebouncedValue, delay, options);
    // Update the debounced value if the initial value changes
    if (!eq(previousValueRef.current, unwrappedInitialValue)) {
        updateDebouncedValue(unwrappedInitialValue);
        previousValueRef.current = unwrappedInitialValue;
    }
    return [debouncedValue, updateDebouncedValue];
}
exports.useDebounceValue = useDebounceValue;
