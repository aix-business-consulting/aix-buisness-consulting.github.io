var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { useEffect, useReducer, useRef } from 'react';
/**
 * Custom hook for making HTTP requests and managing the state of the request.
 * @template T - The type of data expected in the response.
 * @param {string | undefined} url - The URL to make the HTTP request to.
 * @param {RequestInit} [options] - The [options for the HTTP request]() (optional).
 * @returns {State<T>} The state object representing the result of the HTTP request.
 * @see [Documentation](https://usehooks-ts.com/react-hook/use-fetch)
 * @see [MDN Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)
 * @example
 * const { data, error } = useFetch<User>('https://api.example.com/user');
 */
export function useFetch(url, options) {
    const cache = useRef({});
    // Used to prevent state update if the component is unmounted
    const cancelRequest = useRef(false);
    const initialState = {
        error: undefined,
        data: undefined,
    };
    // Keep state logic separated
    const fetchReducer = (state, action) => {
        switch (action.type) {
            case 'loading':
                return Object.assign({}, initialState);
            case 'fetched':
                return Object.assign(Object.assign({}, initialState), { data: action.payload });
            case 'error':
                return Object.assign(Object.assign({}, initialState), { error: action.payload });
            default:
                return state;
        }
    };
    const [state, dispatch] = useReducer(fetchReducer, initialState);
    useEffect(() => {
        // Do nothing if the url is not given
        if (!url)
            return;
        cancelRequest.current = false;
        const fetchData = () => __awaiter(this, void 0, void 0, function* () {
            dispatch({ type: 'loading' });
            // If a cache exists for this url, return it
            if (cache.current[url]) {
                dispatch({ type: 'fetched', payload: cache.current[url] });
                return;
            }
            try {
                const response = yield fetch(url, options);
                if (!response.ok) {
                    throw new Error(response.statusText);
                }
                const data = (yield response.json());
                cache.current[url] = data;
                if (cancelRequest.current)
                    return;
                dispatch({ type: 'fetched', payload: data });
            }
            catch (error) {
                if (cancelRequest.current)
                    return;
                dispatch({ type: 'error', payload: error });
            }
        });
        void fetchData();
        // Use the cleanup function for avoiding a possibly...
        // ...state update after the component was unmounted
        return () => {
            cancelRequest.current = true;
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [url]);
    return state;
}
